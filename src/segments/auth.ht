import 'module:std' as std
import 'module:spotube_plugin' as spotube
import { TOTP, OTPAlgorithm } from '../../dependencies/hetu_otp_util/lib/assets/hetu/otp_util.ht';

var StreamController = std.StreamController
var Stream = std.Stream
var StreamSubscription = std.StreamSubscription
var DateTime = std.DateTime
var Duration = std.Duration
var HttpClient = std.HttpClient
var HttpResponse = std.HttpResponse
var RequestOptions = std.RequestOptions
var Timer = std.Timer
var JSON = std.JSON
var Regex = std.Regex
var LocalStorage = spotube.LocalStorage
var Webview = spotube.Webview
var Cookie = spotube.Cookie

class SpotifyAuthEndpoint {
  final controller: StreamController
  var _timer: Timer
  /// Map of:
  /// - `cookies`: Map of cookies from <Cookie>.toJson()
  /// - `accessToken`: The access token string
  /// - `expiration`: The expiration timestamp in milliseconds since epoch
  var credentials: Map
  var client: HttpClient

  get authStateStream -> Stream => controller.stream

  construct (onEvent: (data) -> void){
    controller = StreamController.broadcast()
    client = HttpClient()

    controller.stream.listen((event) {
      if(onEvent != null) {
        onEvent(event)
      }
      if(event["type"] == "recovered" || event["type"] == "login") {
        _timer?.cancel()
        _timer = Timer.periodic(getExpirationDuration(), (cancel){
          refreshCredentials()
        })
      }
    })

    initializeFromLocalStorage()
  }

  fun isExpired() -> bool {
		if (credentials == null) {
			return true
		}

		final currentTime = DateTime.now()

		final expirationTime = DateTime.fromMillisecondsSinceEpoch(credentials["expiration"])

		return currentTime.isAfter(expirationTime)
	}

  fun getExpirationDuration() -> Duration {
		if (credentials == null) {
			return 0;
		}

		final currentTime = DateTime.now()

		final expirationTime = DateTime.fromMillisecondsSinceEpoch(credentials["expiration"])

		return expirationTime.difference(currentTime)
	}


  fun initializeFromLocalStorage() {
		LocalStorage.getString("credentials").then((credentialsStr){
      if (credentialsStr != null) {
        credentials = JSON.decode(credentialsStr);
        if (isExpired()) {
          refreshCredentials()
        } else {
          controller.add({ type: "recovered" }.toJson())
        }
      }
    })
	}

  fun getLatestNuance() -> Future { // Future<{v: int, s: string}>
    return client.get_req(
      "https://codeberg.org/sonic-liberation/blubber-junkyard-elitism/raw/branch/main/nuances.json"
    ).then((res) {
      var data = JSON.decode(res.data);
      data.sort((a, b) => b["v"].compareTo(a["v"]))
      return data.first
    })
  }

  fun generateTimedOnTimePassword(secret: string) -> Future {
		return client.get_req("https://open.spotify.com/api/server-time")
    .then((res) {
      final timestampSeconds = res.data["serverTime"]

      final totp = TOTP(
        secret: secret,
        algorithm: OTPAlgorithm.SHA1,
        digits: 6,
        interval: 30,
      )

      return totp.value(
        date: DateTime.fromMillisecondsSinceEpoch(
          timestampSeconds * 1000 // Convert seconds to milliseconds
        )
      )
    })
	}

  fun randomBytesFromMath(length: int) -> string {
    var bytes = List()

    for (int i = 0; i < length; i++) {
      bytes.add(Random().nextInt(256).toString())
    }
  }

  fun getToken({
		mode = "transport",
		timestamp: DateTime,
		totp: string,
		spDc: string,
    mode: string,
    totpVer: int
	}) -> Future {
    print("Timestamp: ${timestamp}, TOTP: ${totp}, Mode: ${mode}, spDc: ${spDc}")
    final timestampSeconds = (timestamp.millisecondsSinceEpoch / 1000).floor()
		final accessTokenUrl = "https://open.spotify.com/api/token?reason=${mode}&productType=web-player&totp=${totp}&totpServer=${totp}&totpVer=${totpVer}"

		final userAgent = "${DateTime.now().millisecondsSinceEpoch}${Random().nextInt(100) * 1000}${randomBytesFromMath(16)}"
    .split("").join("")

		return client.get_req(
      accessTokenUrl, 
      options: RequestOptions(
        headers: {
          Cookie: spDc ?? "",
          "User-Agent": userAgent,
        }.toJson(),
      )
    ).then((res){
      return { body: res.data, headers: res.headers }
    })
	}

  fun credentialsFromCookie(cookies: List) -> Future {
		final spDc = cookies.where((c) => c["name"] == "sp_dc").first?["value"];

    return getLatestNuance().then((nuance){
      return generateTimedOnTimePassword(nuance["s"]).then((totp){
        return getToken(
          totp: totp,
          timestamp: DateTime.now(),
          spDc: "sp_dc=${spDc};",
          mode: "transport",
          totpVer: nuance["v"],
        ).then((res){
          if (res.body["accessToken"] == null) {
            print(
              "The access token is only ${res.body["accessToken"]?.length} characters long instead of 374. Your authentication probably doesn't work",
            );
          }

          return {
            cookies: cookies,
            accessToken: res.body["accessToken"],
            expiration: res.body["accessTokenExpirationTimestampMs"],
          }
        })
      })
    })
	}
  
  fun isAuthenticated() -> bool {
    return credentials != null && !isExpired()
  }
  
  fun login(cookies: List) -> Future {
		return this.credentialsFromCookie(cookies).then((creds){
      LocalStorage.setString("credentials", JSON.encode(creds.toJson()));
      credentials = creds;

      controller.add({type: "login"}.toJson());
    })
	}

	fun refreshCredentials() -> Future {
		if (credentials["cookies"] == null) {
			print(
				"[refreshCredentials] No cookie found. Cannot refresh credentials.",
			);
			return;
		}
		return this.credentialsFromCookie(credentials["cookies"]).then((creds){
      LocalStorage.setString("credentials", JSON.encode(creds.toJson()));
      credentials = creds;
      controller.add({ type: "refreshed" }.toJson())
    })
	}

  fun authenticate() -> Future {
    var webview = Webview(uri: "https://accounts.spotify.com/")

    var sub: StreamSubscription = webview.onUrlRequestStream.listen((url){
      var safeUrl = url.endsWith("/") ? url.substring(0, url.length - 1) : url
      var exp = Regex("https:\\/\\/accounts.spotify.com\\/.+\\/status")
      if(exp.hasMatch(safeUrl)) {
        return webview.getCookies(url).then((cookies){
          return login(cookies.map((cookie)=> cookie.toJson()).toList()).then(() {
            return webview.close()
          })
        })
      }
    })

    return webview.open()
  }

	fun logout() {
		credentials = null;
		LocalStorage.remove("credentials");
		controller.add({type: "logout"}.toJson());
	}
}

export { SpotifyAuthEndpoint }